As an individual who started with dev before graduating (when I did not know how abstracted code is working) and started early career in semiconductor domain as a software engineer enriched with operations, I am quenching my thirst of understanding the hardware-software interaction and trying to build a very strong foundation for the software engineering roles be it development, be it devops, etc. Software work (event driven architecture) heavy with operations probably made me more curious day by day and it truly has given me a better perspective of how we can be a strong developer/programmer and what things we need to consider when we code/design.

1. Before I used to do dev in a way that go ahead and follow documentation, write code, it runs and you are done. Now, the curiosity has led me to see what "runs" actually means, what happens after we deploy, what breaks in real environment, what performance, memory, reliability, latency, networking, failures, users and infrastructure actually look like in reality. How the systems live, evolve, degrade and require care! It enforced me to confront the real behavior of software.
2. When we code, it makes us think about WHAT if questions? What if network drops, what if 10x traffic arrives, what if dependency dies? You should design resilient systems. Before - "Runtime = app is executing". After - "Runtime = CPU scheduling, container memory constraints, thread pools, GC behavior, file descriptors, network sockets, retries, timeouts, TLS handshakes, DNS failures, scaling behavior, monitoring, alerts, logging, etc! It helped me mentally seeing the architecture while coding. Documentation does say that do x, so I'll do its part. But does it make sense for prod, security, latency, users, failures, scale? That's the reality. Now for me coder and engineer are two different categories. Engineering is more about understanding constraints, making tradeoffs, predicting failures, designing for real life and thinking about cost, reliability, users and operations. While coding (writing instructions), bringing your engineering knowledge makes you a better coder. 