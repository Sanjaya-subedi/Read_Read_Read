# Code – Concepts Learned / Revised

**Book:** Code - The Hidden Language of Computer Hardware and Software 
**Author:** Charles Petzold

Information ≠ electricity
Information = interpretation of signals

## WHAT CONCEPTS DID I LEARN / REVISE

## Information Encoding
- Information can be represented using physical states (on/off, high/low).
- Morse code demonstrates that meaning comes from agreed-upon encoding, not the medium itself.
- Binary is reliable because it tolerates noise better than continuous values.

## Binary Numbers
- Binary is base-2 representation using only 0 and 1.
- Any number, character, or instruction can be represented in binary.
- Hexadecimal and decimal are human-friendly views layered on top of binary.

## Switches and Relays
- Switches represent physical implementations of binary states.
- Relays allow one electrical signal to control another, enabling conditional behavior.
- This forms the earliest foundation of programmable machines.

## Logic Gates
- AND, OR, NOT gates are built from switches and electrical rules.
- Gates are physical devices, not abstract ideas.
- Complex logic emerges from combinations of simple gates.

## Boolean Logic
- Boolean algebra governs how logic gates behave.
- Logical expressions map directly to physical circuits.
- This creates a tight relationship between mathematics and hardware.

## Arithmetic Circuits
- Adders are built from XOR, AND, and OR gates.
- Subtraction, multiplication, and division are layered on addition.
- Arithmetic units demonstrate how math is mechanized.

## Memory and State
- Memory requires feedback loops to preserve state.
- Latches and flip-flops store bits.
- RAM is a structured collection of these storage elements.

## Clocks and Timing
- Clock signals synchronize operations across circuits (A clock is introduced as a regular on/off signal like blinking light. Logic circuits does not just compute, they compute in time. Each clock captures inputs, updates memory, moves calculation one step forward. Without clocks, we have just circuits but with clocks, we have computers). 
- Clock is a periodic electric signal that alternates between two voltage levels (0 and 1) at a regular interval. A clock is generated by the hardware, using an oscillator. Power ON -> Oscillator starts oscillating  -> Clock signal begins. The clock never stops while the system is powered (unless deliberately gated). The clock does not perform computation, it synchronizes all parts of the system, tells memory when to store, tells logic when to move to the next step.
- Timing ensures predictable execution.
- Faster clocks increase performance but raise power and heat concerns.

## Instruction Sets
- CPUs execute instructions encoded as binary patterns.
- Instructions tell the processor what operation to perform and on which data.
- This is the boundary between hardware and software.

## Machine Code and Assembly
- Machine code is raw binary understood by the CPU.
- Assembly language provides human-readable mnemonics.
- Assemblers translate symbolic instructions into binary.

## Abstraction Layers
- Hardware → Logic → Machine Code → Assembly → High-Level Languages (In this flow, we can think of Operating System in Machine Code and Assembly part as OS is implemented in machine code and assembly (kernel, drivers) and it manages access to hardware for programs written in high level languages).
- Each layer simplifies reasoning while relying on the correctness of the layer below.
- Bugs and inefficiencies often occur when abstractions leak.

## Key Insight
- Computers are not fundamentally about software.
- They are about **controlled flow of information**, implemented through physics, logic, and disciplined abstraction.
